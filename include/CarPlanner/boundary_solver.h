#pragma once

#include <CarPlanner/utils/vector.h>

/// A structure containing the 2D boundary value problem inputs and outputs. This is passed to the boundary solver
/// class in order to obtain a valid control law, which is also written to this structure.
struct boundary_problem
{
    enum boundary_problemType
    {
        eBoundary_Point = 1,
        eBoundary_Trajectory = 2
    };

    boundary_problem()
    { }

    virtual ~boundary_problem() {}

    //inputs into the solver
    Eigen::Vector4d start_pose_;   //< Starting 2D pose for the boundary value solver, which is parametrized as [x,y,theta,curvature]'
    Eigen::Vector4d m_goal_pose_;    //< Goal 2D pose for the boundary value solver, which is parametrized as [x,y,theta,curvature]'

    Eigen::Vector4dAlignedVec m_vTrajectory;
    double m_dMaxCurvature;         //< Maximum curvature desired from the trajectory. This could correspond to the maximum turning capability of the vehicle
    int m_nDiscretization;          //< The number of steps required along the trajectory

    //outputs from the solver
    std::vector<double> m_vCurvatures;      //< Output: Curvature law generated by the solver. The length is equal to m_nDiscretization
    Eigen::Vector2dAlignedVec m_vPts;    //< Output: The 2d points of the control law. The length is equal to m_nDiscretization
    double m_dDistance;                     //< Output: The total distance of the control law generated. This is in meters
    boundary_problemType m_eType;
};

class BoundarySolver
{
public:
    BoundarySolver() {}
    virtual ~BoundarySolver() {}
    /// Solves the 2D boundary problem with the given problem description struct
    virtual void Solve(boundary_problem* pProblem) = 0;
    /// Get the curvature at a particular distance along the curve
    virtual double curvature(const boundary_problem *pProblem, double dist) = 0;
};
